问题一：
core_algorithm(time, array_people) 中
既然time参数设置了算法的结束时间，那么怎么知道算法的起始时间？
（最外层的循环应该是for t in range(起始时间，结束时间)）

答:初始时间必为0。t=1的状态可以由t=0的状态计算得出，怎么计算见电梯调度算法.txt 然后由t=1算t=2 ... 一直迭代算到t=time，再返回

按照我的理解，core_algorithm似乎应该不停地调用，以此来更新界面的状态
那有没有可能删去time参数，然后默认起始时间是t,返回时间是t+1，再依靠一个全局变量time来控制时间

答：我希望python算法层内部不存在状态，每次对算法层的调用都是独立的，每次调用得到的输出都只与这次调用的输入有关，与以前的输入无关。参照...上学期数字电路，没有寄存器前的那种电路，简单的不行。有了寄存器和时序电路以后就变得鬼畜多了，所以希望算法层是没有状态的。

也就是说，处理完 电梯移动0.5/单人进出  里面的任何一个事件后，算法就直接返回一个状态？

答：一直迭代到t=time，再返回t时的状态

---------------------------------
问：
1.需不需要考虑电梯人满的问题？如果考虑要怎么实现
在电梯调度算法.txt 中已经有考虑了,因为对于满人这一块逻辑,就是人想进电梯的时候进行一个判断,如果电梯里人满了就不接受新的人进来
2.person对象中from_floor==to_floor（出发和目的楼层是同一层），感觉是个要出Bug的地方...如何避免（没有这种人出现是最好的）
可以保证不出现这种人
3.电梯停靠时人的进出也花费时间，这个时间怎么定合适（1秒进/出一个人？），需不需要根据实际情况来调整这个参数？
我觉得1秒/1人比较合理,但改成参数的话也很方便
4.感觉给elevator类加一个   elevator_people = []  属性会比较方便，不然每次都要遍历所有人来判断is_in_elevator
我感觉这样要维护数据一致性,没维护好的话很容易出bug.计算量的话...相信电脑的性能,处理这么小规模的数据是没有问题的