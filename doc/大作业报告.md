# 工程概论 - 电梯调度模拟

## 软件设计思路

### 问题建模及基本假设

查阅18层大楼的层高和电梯速度，再结合便于软件开发的目的，不妨设电梯的速度为 0.5层/秒，且为匀速运动，没有加减速过程。

考虑到实际电梯容量和便于图形化的原因，不妨设电梯容量为12人。

考虑到进出电梯的人越多，电梯停留时间越长，不妨设为每秒钟电梯可以出一人或者进一人。

考虑到出现人群的分布不是均匀的，尤其在 1楼 有非常大的吞吐量，所以设置人群生成规则如下：

    25%的人群:1楼出发,到达 random(0,20)

    25%的人群:random(0,20)出发,到达1楼

    50%的人群:random(0,20)出发 到达 random(0,20)

设人群的人数为 random(1,5)

### 核心算法设计

### 技术选型

首先，在所有同学都已经有 C 和 Java 学习经验的基础上，最关键的技术瓶颈在于GUI层。经过交流，团队中只有一名同学掌握有 GUI 开发的经验，技术栈是 .NET 的 C# + WPF。

但是会 C# 的只有一人，如果承担了所有的开发工作就会导致效率低下，所以要将程序解耦为算法层和GUI层。后来算法同学决定使用 Python。因为程序的数据规模非常低，使用 Python 不会造成性能瓶颈，而且可以降低语言层面的复杂度。

算法层和GUI层之间的通信，一开始使用了命令行调用、标准输入输出的方式。算法层和GUI层定义了一致的数据结构，并且使用 JSON 进行数据传递。

但这种方式需要使用者也拥有 Python 环境，且该方式在非GUI开发者的电脑上出现异常，难以调试。所以决定转用 HTTP 协议，使用 Flask 对算法进行服务端的封装，再使用 Docker 部署在服务器上，对外提供API。这样使用者的电脑只需要 .NET Framework 环境就可以运行程序。此外，以后还可以使用 Web 端 / QT 等不同前端技术开发运行在不同操作系统上的前端程序。

## 软件功能

## 结构框图

## 软件流程图

## 运行界面截图

## 运行结果

## 软件测试及截图

## This is test image

![test](images\test.png)

## 人员分工
