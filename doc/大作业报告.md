# 工程概论 - 电梯调度模拟

## 软件设计思路

### 问题建模及基本假设

### 核心算法设计
#### 算法简介
  该电梯调度算法主要基于LOOK调度算法。该算法按照楼层顺序依次服务请求，它让电梯在最底层和最顶层之间连续往返运行，在运行过程中响应处在于电梯运行方向相同的各楼层上的请求，当LOOK算法发现电梯所移动的方向上不再有请求时立即改变运行方向，从而实现对电梯的有效调度。
#### 说明
  在要处理的问题中，建筑具有地上18层与地下3层，方便起见，我们将-3层设置为0层，其余楼层在此基础上增加。
#### 基本类
**person**：搭乘电梯的乘客。其属性包括：come_time（出现的时间）、from_floor（起始楼层）
to_floor（目标楼层）、current_floor（当前楼层）、in_which_elevator（所在电梯,可取0，1，2，3，分别指不在电梯中、在第一个电梯中、在第二个电梯中、在第三个电梯中）、is_out（是否完成电梯乘坐）  
**elevator**：电梯。其属性包括：current_floor（当前楼层）、move_direction（运行方向）。  
**floor**：楼层。其属性包括：floor_up_people = []（上行人群）、self.floor_down_people = []（下行人群）、up_button（上升按钮）、down_button（下降按钮）。
#### 算法
```python
//已知第t秒时的状态,进行调度,给出t+1时的状态  
时间循环（每循环一轮为一秒）  
     //处理person到达事件  
     遍历person数组，如果p.come_time==t（该乘客首次出现）
        将该乘客分配给对应的楼层
        更新对应楼层电梯按钮
        更新楼层people数组（分为上行人群和下行人群）  
     //处理电梯
    //对每个电梯，根据电梯的move_direction分类处理（move_direction取0，1，2，分别代表电梯静止、上行、下行）
    //（这一秒结束）代表continue，不再执行循环体剩下的部分
    如果电梯静止
        遍历所有楼层，检测楼层电梯按钮
	      如果楼上有人按电梯
            电梯设置为上行（这一秒结束）        
		  如果楼下有人按电梯
            电梯设置为下行（这一秒结束）
		  如果本层楼有人
          如果此人上行
              电梯设置为上行（这一秒结束）
          如果此人下行
              电梯设置为下行（这一秒结束）
   如果电梯上行
       如果电梯没有对齐某一楼层（如在3.5层）
           电梯向上运行半层
           更新乘客状态（这一秒结束）
       如果电梯对齐了某一楼层
           如果电梯中有乘客抵达目标楼层
               更新该乘客的状态（这一秒结束）
           如果电梯人数已满
               电梯向上运行半层
               更新乘客状态（这一秒结束）
           如果楼层有人要进电梯
               更新人的状态
               更新楼层的状态
               如果楼层上行person数组为空
                   楼层上行按钮置False
                   （这一秒结束）
           如果电梯内人数不为零
               向上半层，并且更新乘客状态（这一秒结束）
           如果电梯内人数为零
               如果电梯以上的楼层还有人
                   向上半层，并且更新乘客状态（这一秒结束）
               如果电梯以上的楼层没有人
                   电梯状态改为静止（这一秒结束）
//下行同理
//其余两个电梯同理
```
### 技术选型

首先，在所有同学都已经有 C 和 Java 学习经验的基础上，最关键的技术瓶颈在于GUI层。经过交流，团队中只有一名同学掌握有 GUI 开发的经验，技术栈是 .NET 的 C# + WPF。

但是会 C# 的只有一人，如果承担了所有的开发工作就会导致效率低下，所以要将程序解耦为算法层和GUI层。后来算法同学决定使用 Python。因为程序的数据规模非常低，使用 Python 不会造成性能瓶颈，而且可以降低语言层面的复杂度。

算法层和GUI层之间的通信，一开始使用了命令行调用、标准输入输出的方式。算法层和GUI层定义了一致的数据结构，并且使用 JSON 进行数据传递。

但这种方式需要使用者也拥有 Python 环境，且该方式在非GUI开发者的电脑上出现异常，难以调试。所以决定转用 HTTP 协议，使用 Flask 对算法进行服务端的封装，再使用 Docker 部署在服务器上，对外提供API。这样使用者的电脑只需要 .NET Framework 环境就可以运行程序。此外，以后还可以使用 Web 端 / QT 等不同前端技术开发运行在不同操作系统上的前端程序。

## 软件功能

## 结构框图

## 软件流程图

## 运行界面截图

## 运行结果

## 软件测试截图

## This is test image

![test](images\test.png)

## 人员分工
